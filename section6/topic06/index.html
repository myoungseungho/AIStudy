<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>시퀀스 데이터는 뭐야? - Section 6</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.9;
        }
        .container { max-width: 800px; margin: 0 auto; padding: 60px 20px; }
        .breadcrumb { margin-bottom: 24px; font-size: 0.9rem; }
        .breadcrumb a { color: #666; text-decoration: none; }
        .breadcrumb a:hover { text-decoration: underline; }
        .breadcrumb span { color: #999; margin: 0 8px; }
        .header { margin-bottom: 48px; }
        .topic-number {
            display: inline-block;
            background: #E91E63;
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 16px;
        }
        .header h1 { font-size: 2rem; font-weight: 700; color: #111; margin-bottom: 12px; }
        .header p { color: #666; font-size: 1.1rem; }
        .conversation {
            background: white;
            border-radius: 16px;
            padding: 32px;
            margin: 32px 0;
            border: 1px solid #e0e0e0;
        }
        .conversation h2 {
            font-size: 1.3rem;
            color: #E91E63;
            margin-bottom: 24px;
            padding-bottom: 12px;
            border-bottom: 2px solid #fce4ec;
        }
        .chat { margin-bottom: 20px; }
        .q {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 16px 20px;
            margin: 16px 0;
            border-radius: 0 12px 12px 0;
            font-weight: 500;
        }
        .q::before { content: "Q. "; color: #e65100; font-weight: 700; }
        .a { padding: 8px 0 8px 20px; border-left: 4px solid #e0e0e0; margin: 12px 0; }
        .a p { margin-bottom: 12px; }
        .a p:last-child { margin-bottom: 0; }
        .highlight {
            background: #e3f2fd;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #1565c0;
        }
        .key-point {
            background: #fce4ec;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #c2185b;
        }
        .warning {
            background: #ffcdd2;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #c62828;
        }
        .code-block {
            background: #263238;
            border-radius: 8px;
            padding: 16px 20px;
            margin: 16px 0;
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
            color: #eceff1;
            overflow-x: auto;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .compare-table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            font-size: 0.9rem;
        }
        .compare-table th, .compare-table td {
            padding: 12px;
            border: 1px solid #e0e0e0;
            text-align: left;
        }
        .compare-table th { background: #f5f5f5; font-weight: 600; }
        .summary-box {
            background: linear-gradient(135deg, #E91E63 0%, #EC407A 100%);
            border-radius: 16px;
            padding: 32px;
            color: white;
            margin: 32px 0;
        }
        .summary-box h3 { font-size: 1.2rem; margin-bottom: 20px; }
        .summary-box ul { list-style: none; }
        .summary-box li {
            padding: 8px 0;
            padding-left: 24px;
            position: relative;
        }
        .summary-box li::before {
            content: "→";
            position: absolute;
            left: 0;
            color: #fce4ec;
        }
        .nav-links {
            display: flex;
            justify-content: space-between;
            margin-top: 60px;
            padding-top: 24px;
            border-top: 1px solid #e0e0e0;
        }
        .nav-links a { color: #E91E63; text-decoration: none; font-weight: 500; }
        .nav-links a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container">
        <nav class="breadcrumb">
            <a href="../../">AI 공부</a>
            <span>/</span>
            <a href="../">Section 6</a>
            <span>/</span>
            Topic 06
        </nav>

        <header class="header">
            <div class="topic-number">TOPIC 06</div>
            <h1>시퀀스 데이터는 뭐야?</h1>
            <p>Q. 순서가 중요한 데이터라는 거야?</p>
        </header>

        <div class="conversation">
            <h2>Part 1. 순서가 중요한 데이터</h2>

            <div class="chat">
                <div class="q">시퀀스 데이터(Sequence Data)가 뭐야?</div>
                <div class="a">
                    <p><span class="key-point">순서가 의미를 갖는 데이터</span>야.</p>
                    <p>순서를 바꾸면 의미가 완전히 달라지는 거지.</p>
                </div>
            </div>

            <div class="code-block">비유: 순서가 중요한 것들

요리 레시피:
✅ 1. 물을 끓인다 → 2. 라면을 넣는다 → 3. 3분 기다린다
❌ 1. 3분 기다린다 → 2. 라면을 넣는다 → 3. 물을 끓인다
→ 순서 바뀌면 라면 망가짐!

문장:
✅ "나는 학교에 간다"
❌ "간다 학교에 나는"
→ 순서 바뀌면 의미 이상해짐

숫자 리스트 (시퀀스 아님):
✅ [1, 5, 3, 2]
✅ [2, 3, 5, 1]
→ 순서 바뀌어도 그냥 숫자들의 집합일 뿐
</div>

            <div class="chat">
                <div class="q">시퀀스 데이터의 예시는?</div>
            </div>

            <div class="code-block">시퀀스 데이터 예시:

1. 텍스트
   "안녕하세요" → ['안', '녕', '하', '세', '요']
   순서 바뀌면 의미 없음

2. 시계열 데이터
   주식 가격: [100원, 105원, 103원, 108원, ...]
   → 시간 순서가 중요

3. 음성
   "안녕" 발음 → [음성 신호1, 신호2, 신호3, ...]
   → 순서 바뀌면 다른 소리

4. 동영상
   프레임: [이미지1, 이미지2, 이미지3, ...]
   → 순서가 스토리를 만듦

5. DNA 서열
   "ATCG..." → 순서가 유전 정보
</div>
        </div>

        <div class="conversation">
            <h2>Part 2. 왜 시퀀스가 어려워?</h2>

            <div class="chat">
                <div class="q">그냥 처리하면 안 돼?</div>
                <div class="a">
                    <p><span class="warning">일반 신경망으로는 안 돼.</span> 특별한 방법이 필요해.</p>
                </div>
            </div>

            <div class="code-block">문제 1: 길이가 다르다

일반 데이터:
이미지: 항상 256x256 픽셀
→ 입력 크기 고정

시퀀스 데이터:
"안녕" → 2글자
"안녕하세요" → 5글자
"안녕하세요 만나서 반갑습니다" → 14글자
→ 입력 크기가 계속 바뀜!

일반 신경망은 고정된 입력만 받을 수 있어서 문제
</div>

            <div class="code-block">문제 2: 앞뒤 문맥이 중요하다

문장: "은행에 갔다"

"은행" = 금융기관? 강가?
→ 앞뒤 문맥을 봐야 알 수 있음

"돈을 찾으러 은행에 갔다" → 금융기관
"강둑을 따라 은행에 앉았다" → 강가

→ 단어 하나만 보면 안 됨
→ 전체 문장을 순서대로 이해해야 함
</div>

            <div class="code-block">문제 3: 먼 거리의 의존성

"나는 어제 친구를 만났는데, 그 친구가 오랜만에 고향에
다녀왔다고 해서, 그 이야기를 들으면서, 나도 가고 싶다는
생각이 들었다."

→ "나도"는 맨 처음 "나는"을 가리킴
→ 중간에 많은 단어가 있지만 연결되어 있음
→ 먼 거리의 단어들도 관계를 파악해야 함
</div>

            <div class="chat">
                <div class="a">
                    <p>이런 문제들을 해결하기 위해 <span class="key-point">RNN(순환 신경망)</span>이 만들어졌어!</p>
                </div>
            </div>
        </div>

        <div class="conversation">
            <h2>Part 3. 시퀀스 문제의 종류</h2>

            <div class="chat">
                <div class="q">시퀀스로 뭘 할 수 있는데?</div>
                <div class="a">
                    <p>크게 4가지 타입이 있어.</p>
                </div>
            </div>

            <table class="compare-table">
                <tr>
                    <th>타입</th>
                    <th>입력→출력</th>
                    <th>예시</th>
                </tr>
                <tr>
                    <td><strong>One-to-One</strong></td>
                    <td>하나 → 하나</td>
                    <td>이미지 분류 (일반 신경망)</td>
                </tr>
                <tr>
                    <td><strong>One-to-Many</strong></td>
                    <td>하나 → 시퀀스</td>
                    <td>이미지 → 설명문 생성</td>
                </tr>
                <tr>
                    <td><strong>Many-to-One</strong></td>
                    <td>시퀀스 → 하나</td>
                    <td>문장 → 감정 분류</td>
                </tr>
                <tr>
                    <td><strong>Many-to-Many</strong></td>
                    <td>시퀀스 → 시퀀스</td>
                    <td>번역, 요약</td>
                </tr>
            </table>

            <div class="code-block">구체적 예시:

1. One-to-Many (이미지 캡셔닝)
   입력: 🐕 (강아지 사진)
   출력: "A cute dog is playing"
          [단어1, 단어2, 단어3, 단어4, 단어5]


2. Many-to-One (감정 분석)
   입력: "이 영화 정말 재미있어요!"
          [이, 영화, 정말, 재미있어요]
   출력: 😊 (긍정)


3. Many-to-Many (번역)
   입력: "I love you"
          [I, love, you]
   출력: "나는 너를 사랑해"
          [나는, 너를, 사랑해]


4. Many-to-Many (품사 태깅)
   입력: "나는 학교에 간다"
   출력: [명사, 조사, 명사, 조사, 동사]
</div>
        </div>

        <div class="conversation">
            <h2>Part 4. 시퀀스 표현 방법</h2>

            <div class="chat">
                <div class="q">시퀀스를 컴퓨터에 어떻게 입력해?</div>
                <div class="a">
                    <p>단어를 벡터로 바꾸고, 그걸 순서대로 넣어.</p>
                </div>
            </div>

            <div class="code-block">시퀀스를 벡터로:

문장: "나는 학교에 간다"

1. 토큰화
   → ["나는", "학교에", "간다"]

2. 각 단어를 임베딩 벡터로 변환
   "나는"   → [0.1, 0.5, 0.2]
   "학교에" → [0.3, 0.7, 0.1]
   "간다"   → [0.2, 0.4, 0.6]

3. 시퀀스 생성
   [
     [0.1, 0.5, 0.2],  ← 시간 t=1
     [0.3, 0.7, 0.1],  ← 시간 t=2
     [0.2, 0.4, 0.6]   ← 시간 t=3
   ]

4. 순서대로 신경망에 입력
   t=1: [0.1, 0.5, 0.2] 입력 → 처리
   t=2: [0.3, 0.7, 0.1] 입력 → 처리 (t=1 기억하면서)
   t=3: [0.2, 0.4, 0.6] 입력 → 처리 (t=1, t=2 기억하면서)
</div>

            <div class="chat">
                <div class="q">길이가 다르면?</div>
            </div>

            <div class="code-block">Padding (패딩) 사용:

짧은 문장: "안녕"
→ ["안녕", <PAD>, <PAD>, <PAD>]
→ [벡터1, 0, 0, 0]

긴 문장: "안녕하세요"
→ ["안녕", "하세", "요", <PAD>]
→ [벡터1, 벡터2, 벡터3, 0]

더 긴 문장: "안녕하세요 만나서 반갑습니다"
→ 최대 길이로 자르거나 더 긴 패딩 사용

→ 모든 시퀀스를 같은 길이로 맞춤
→ 빈 곳은 0으로 채움
</div>
        </div>

        <div class="conversation">
            <h2>Part 5. 시퀀스 모델의 진화</h2>

            <div class="chat">
                <div class="q">시퀀스를 처리하는 모델이 계속 발전했어?</div>
                <div class="a">
                    <p>응! 점점 더 좋아지고 있어.</p>
                </div>
            </div>

            <div class="code-block">시퀀스 모델의 역사:

1. RNN (1980년대~)
   - 순서대로 처리
   - 이전 정보를 기억
   - 문제: 긴 시퀀스에서 기억 상실

2. LSTM (1997)
   - RNN의 문제 해결
   - 장기 기억 가능
   - 문제: 여전히 느림

3. GRU (2014)
   - LSTM 단순화 버전
   - 더 빠르고 효율적

4. Attention (2014)
   - 중요한 부분에 집중
   - 병렬 처리 가능

5. Transformer (2017)
   - RNN 완전히 제거
   - 어텐션만 사용
   - 엄청 빠르고 성능 좋음
   - ChatGPT, BERT의 기반

→ 지금은 Transformer가 대세!
</div>

            <div class="chat">
                <div class="a">
                    <p>다음 토픽들에서 RNN부터 하나씩 배워볼 거야!</p>
                </div>
            </div>
        </div>

        <div class="summary-box">
            <h3>핵심 정리</h3>
            <ul>
                <li><strong>시퀀스 데이터</strong> - 순서가 의미를 갖는 데이터 (텍스트, 시계열, 음성 등)</li>
                <li><strong>주요 어려움</strong> - 가변 길이, 문맥 이해, 장거리 의존성</li>
                <li><strong>4가지 타입</strong> - One-to-Many, Many-to-One, Many-to-Many 등</li>
                <li><strong>처리 방법</strong> - 단어를 벡터로 바꿔서 순서대로 입력</li>
                <li><strong>모델 진화</strong> - RNN → LSTM → Attention → Transformer</li>
            </ul>
        </div>

        <div class="nav-links">
            <a href="../topic05/">← 이전: Word2Vec은 어떻게 학습해?</a>
            <a href="../topic07/">다음: RNN은 왜 필요해? →</a>
        </div>
    </div>
</body>
</html>
