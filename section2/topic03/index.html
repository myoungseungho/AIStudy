<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>벡터로 단어를 표현한다고? - Section 2</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #fafafa;
            color: #333;
            line-height: 1.9;
        }
        .container { max-width: 800px; margin: 0 auto; padding: 60px 20px; }
        .breadcrumb { margin-bottom: 24px; font-size: 0.9rem; }
        .breadcrumb a { color: #666; text-decoration: none; }
        .breadcrumb a:hover { text-decoration: underline; }
        .breadcrumb span { color: #999; margin: 0 8px; }
        .header { margin-bottom: 48px; }
        .topic-number {
            display: inline-block;
            background: #FF9800;
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 16px;
        }
        .header h1 { font-size: 2rem; font-weight: 700; color: #111; margin-bottom: 12px; }
        .header p { color: #666; font-size: 1.1rem; }
        .conversation {
            background: white;
            border-radius: 16px;
            padding: 32px;
            margin: 32px 0;
            border: 1px solid #e0e0e0;
        }
        .conversation h2 {
            font-size: 1.3rem;
            color: #FF9800;
            margin-bottom: 24px;
            padding-bottom: 12px;
            border-bottom: 2px solid #fff3e0;
        }
        .chat { margin-bottom: 20px; }
        .q {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 16px 20px;
            margin: 16px 0;
            border-radius: 0 12px 12px 0;
            font-weight: 500;
        }
        .q::before { content: "Q. "; color: #e65100; font-weight: 700; }
        .a {
            padding: 8px 0 8px 20px;
            border-left: 4px solid #e0e0e0;
            margin: 12px 0;
        }
        .a p { margin-bottom: 12px; }
        .a p:last-child { margin-bottom: 0; }
        .highlight {
            background: #e3f2fd;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #1565c0;
        }
        .key-point {
            background: #fff3e0;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #e65100;
        }
        .warning {
            background: #ffcdd2;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #c62828;
        }
        .code-block {
            background: #263238;
            border-radius: 8px;
            padding: 16px 20px;
            margin: 16px 0;
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
            color: #eceff1;
            overflow-x: auto;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .compare-table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            font-size: 0.9rem;
        }
        .compare-table th, .compare-table td {
            padding: 12px;
            border: 1px solid #e0e0e0;
            text-align: left;
        }
        .compare-table th {
            background: #f5f5f5;
            font-weight: 600;
        }
        .summary-box {
            background: linear-gradient(135deg, #FF9800 0%, #FFB74D 100%);
            border-radius: 16px;
            padding: 32px;
            color: white;
            margin: 32px 0;
        }
        .summary-box h3 { font-size: 1.2rem; margin-bottom: 20px; }
        .summary-box ul { list-style: none; }
        .summary-box li {
            padding: 8px 0;
            padding-left: 24px;
            position: relative;
        }
        .summary-box li::before {
            content: "→";
            position: absolute;
            left: 0;
            color: #fff3e0;
        }
        .nav-links {
            display: flex;
            justify-content: space-between;
            margin-top: 60px;
            padding-top: 24px;
            border-top: 1px solid #e0e0e0;
        }
        .nav-links a { color: #FF9800; text-decoration: none; font-weight: 500; }
        .nav-links a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <div class="container">
        <nav class="breadcrumb">
            <a href="../../">AI 공부</a>
            <span>/</span>
            <a href="../">Section 2</a>
            <span>/</span>
            Topic 03
        </nav>

        <header class="header">
            <div class="topic-number">TOPIC 03</div>
            <h1>벡터로 단어를 표현한다고?</h1>
            <p>Q. "사과"를 숫자로 어떻게 바꿔?</p>
        </header>

        <!-- Part 1: 왜 단어를 숫자로 -->
        <div class="conversation">
            <h2>Part 1. 왜 단어를 숫자로 바꿔야 해?</h2>

            <div class="chat">
                <div class="q">AI는 텍스트를 그냥 읽으면 안 돼? 왜 숫자로 바꿔?</div>
                <div class="a">
                    <p><span class="key-point">컴퓨터는 숫자밖에 못 다뤄.</span></p>
                    <p>글자는 컴퓨터한테 의미가 없어. 계산도 안 돼.</p>
                </div>
            </div>

            <div class="code-block">문제:

"사과"랑 "배"가 얼마나 비슷한지 어떻게 계산해?

"사과" - "배" = ???
→ 글자로는 계산 불가능


해결:

"사과" = [0.8, 0.6, 0.9, ...]
"배"   = [0.3, 0.7, 0.7, ...]

→ 벡터 내적으로 유사도 계산 가능!</div>

            <div class="chat">
                <div class="a">
                    <p>이해됐지?</p>
                    <p><span class="highlight">단어를 벡터로 바꿔야 계산이 가능해.</span></p>
                </div>
            </div>
        </div>

        <!-- Part 2: 단순한 방법 원핫인코딩 -->
        <div class="conversation">
            <h2>Part 2. 제일 간단한 방법: 원핫 인코딩</h2>

            <div class="chat">
                <div class="q">어떻게 단어를 숫자로 바꾸는데?</div>
                <div class="a">
                    <p>제일 간단한 방법부터 볼게. <strong>원핫 인코딩(One-Hot Encoding)</strong>이야.</p>
                </div>
            </div>

            <div class="code-block">단어장:
1. 사과
2. 배
3. 포도
4. 자동차


원핫 인코딩:

"사과"   = [1, 0, 0, 0]  ← 1번 위치만 1
"배"     = [0, 1, 0, 0]  ← 2번 위치만 1
"포도"   = [0, 0, 1, 0]  ← 3번 위치만 1
"자동차" = [0, 0, 0, 1]  ← 4번 위치만 1

→ 자기 위치만 1, 나머지는 0</div>

            <div class="chat">
                <div class="q">이거면 되는 거 아니야?</div>
                <div class="a">
                    <p><span class="warning">문제가 있어.</span></p>
                </div>
            </div>

            <div class="code-block">원핫 인코딩의 문제점:

1. 단어장이 크면 벡터도 커짐
   → 100만 단어 = 100만 차원 벡터
   → 메모리 낭비

2. 의미를 전혀 표현 못함
   "사과" = [1, 0, 0, 0]
   "배"   = [0, 1, 0, 0]

   내적 = 1*0 + 0*1 + 0*0 + 0*0 = 0
   → 완전히 다른 것처럼 보임
   → 실제로는 둘 다 과일인데!


3. 모든 단어가 똑같이 다름
   "사과" vs "배"의 유사도 = 0
   "사과" vs "자동차"의 유사도 = 0
   → 의미 관계를 전혀 못 잡음</div>

            <div class="chat">
                <div class="a">
                    <p><span class="highlight">그래서 더 똑똑한 방법이 필요해.</span></p>
                </div>
            </div>
        </div>

        <!-- Part 3: 워드 임베딩 -->
        <div class="conversation">
            <h2>Part 3. 똑똑한 방법: 워드 임베딩</h2>

            <div class="chat">
                <div class="q">그럼 어떻게 해?</div>
                <div class="a">
                    <p><span class="key-point">워드 임베딩(Word Embedding)</span>을 써.</p>
                    <p>단어의 <strong>의미</strong>를 담은 벡터로 표현하는 거야.</p>
                </div>
            </div>

            <div class="code-block">워드 임베딩 예시 (단순화):

"사과"   = [0.8, 0.2, 0.1, 0.6, 0.9]
"배"     = [0.7, 0.3, 0.2, 0.5, 0.8]
"포도"   = [0.6, 0.4, 0.3, 0.4, 0.7]
"자동차" = [0.1, 0.9, 0.8, 0.2, 0.1]

→ 각 차원이 어떤 "의미"를 담음
→ 예: 1번 = 과일인가, 2번 = 기계인가, 3번 = 크기, ...


유사도 계산:

"사과" · "배" = 높음 (둘 다 과일)
"사과" · "자동차" = 낮음 (전혀 다름)

→ 의미적 유사도를 수치로 표현!</div>

            <div class="chat">
                <div class="q">이 벡터는 어떻게 만드는 거야?</div>
                <div class="a">
                    <p><span class="highlight">AI가 학습해서 만들어.</span></p>
                    <p>엄청 많은 텍스트를 읽으면서 <strong>"비슷한 맥락에 나오는 단어는 비슷한 의미"</strong>라는 규칙으로 학습해.</p>
                </div>
            </div>
        </div>

        <!-- Part 4: Word2Vec -->
        <div class="conversation">
            <h2>Part 4. Word2Vec: 어떻게 학습하나?</h2>

            <div class="chat">
                <div class="q">구체적으로 어떻게 학습하는 거야?</div>
                <div class="a">
                    <p>가장 유명한 방법: <strong>Word2Vec</strong></p>
                    <p>핵심 아이디어: <span class="key-point">"주변 단어를 보면 의미를 알 수 있다"</span></p>
                </div>
            </div>

            <div class="code-block">학습 예시:

문장: "나는 사과를 먹었다"

AI가 학습하는 것:
"나는 ___를 먹었다" → "사과"가 들어감
"나는 사과를 ___" → "먹었다"가 들어감

→ "사과" 주변에 "먹다", "과일", "달다" 같은 단어가 자주 등장
→ "사과" 벡터를 조정해서 이런 단어들과 비슷하게 만듦


여러 문장에서:
"나는 배를 먹었다"
"사과는 맛있다"
"배는 달다"

→ "사과"와 "배"는 비슷한 맥락에 등장
→ 벡터도 비슷하게 조정됨!</div>

            <div class="chat">
                <div class="a">
                    <p>수백만 개 문장을 학습하면:</p>
                    <p><strong>의미적으로 비슷한 단어 = 벡터가 비슷함</strong></p>
                </div>
            </div>
        </div>

        <!-- Part 5: 벡터 연산의 마법 -->
        <div class="conversation">
            <h2>Part 5. 벡터 연산의 마법</h2>

            <div class="chat">
                <div class="q">워드 임베딩으로 뭘 할 수 있어?</div>
                <div class="a">
                    <p>놀라운 일이 일어나:</p>
                </div>
            </div>

            <div class="code-block">유명한 예시:

"왕" - "남자" + "여자" = "여왕"

실제 벡터 계산:
vec("왕") - vec("남자") + vec("여자") ≈ vec("여왕")

→ 단어 의미를 벡터로 계산 가능!


다른 예시:

"한국" - "서울" + "도쿄" ≈ "일본"
"먹다" - "음식" + "책" ≈ "읽다"

→ 단어 간의 관계를 수학적으로 표현</div>

            <div class="chat">
                <div class="q">이게 정말 돼?</div>
                <div class="a">
                    <p><span class="highlight">응, 실제로 돼.</span></p>
                    <p>Google의 Word2Vec이나 최신 모델들은 이런 관계를 놀랍게 잘 잡아.</p>
                </div>
            </div>

            <table class="compare-table">
                <tr>
                    <th>연산</th>
                    <th>결과</th>
                    <th>의미</th>
                </tr>
                <tr>
                    <td>Paris - France + Italy</td>
                    <td>≈ Rome</td>
                    <td>수도 관계</td>
                </tr>
                <tr>
                    <td>King - Man + Woman</td>
                    <td>≈ Queen</td>
                    <td>성별 관계</td>
                </tr>
                <tr>
                    <td>Walking - Walk + Swim</td>
                    <td>≈ Swimming</td>
                    <td>동사 형태</td>
                </tr>
            </table>
        </div>

        <!-- Part 6: 실제 사용 -->
        <div class="conversation">
            <h2>Part 6. 실제로는 어떻게 써?</h2>

            <div class="chat">
                <div class="q">ChatGPT도 이렇게 쓰는 거야?</div>
                <div class="a">
                    <p>원리는 비슷한데, 훨씬 더 복잡해.</p>
                    <p>최신 모델은 <strong>Transformer</strong> 구조를 써서 더 정교하게 만들어.</p>
                </div>
            </div>

            <div class="code-block">발전 과정:

1세대: 원핫 인코딩 (2000년대)
→ 의미 표현 못함

2세대: Word2Vec, GloVe (2013~)
→ 의미 벡터 학습
→ 300차원 정도

3세대: BERT, GPT (2018~)
→ 문맥까지 고려
→ 768~1536차원
→ 같은 단어도 문맥에 따라 다른 벡터

4세대: GPT-3, GPT-4 (2020~)
→ 수천 차원
→ 엄청난 의미 표현력</div>

            <div class="chat">
                <div class="q">파이썬으로는 어떻게 쓰는데?</div>
                <div class="a">
                    <p>라이브러리로 쉽게 쓸 수 있어:</p>
                </div>
            </div>

            <div class="code-block">from gensim.models import Word2Vec

# 문장 데이터
sentences = [
    ["나는", "사과를", "먹었다"],
    ["나는", "배를", "먹었다"],
    ["사과는", "맛있다"]
]

# 모델 학습
model = Word2Vec(sentences, vector_size=100, window=5, min_count=1)

# 단어 벡터 확인
vec_apple = model.wv["사과를"]
print(vec_apple)  # 100차원 벡터

# 유사 단어 찾기
similar = model.wv.most_similar("사과를")
print(similar)  # [("배를", 0.85), ...]</div>
        </div>

        <!-- 핵심 정리 -->
        <div class="summary-box">
            <h3>핵심 정리</h3>
            <ul>
                <li><strong>단어는 벡터로 변환해야 계산 가능</strong> - 컴퓨터는 숫자만 처리</li>
                <li><strong>원핫 인코딩은 너무 단순</strong> - 의미를 전혀 표현 못함</li>
                <li><strong>워드 임베딩이 핵심</strong> - 의미를 담은 벡터로 표현</li>
                <li><strong>비슷한 맥락 = 비슷한 벡터</strong> - AI가 문장을 읽으며 학습</li>
                <li><strong>벡터 연산으로 의미 계산</strong> - "왕 - 남자 + 여자 = 여왕"</li>
                <li><strong>ChatGPT는 더 복잡한 버전</strong> - 문맥까지 고려하는 임베딩</li>
            </ul>
        </div>

        <div class="nav-links">
            <a href="../topic02/">← 이전: 벡터가 뭐야?</a>
            <a href="../topic04/">다음: 행렬은 왜 쓰는 거야? →</a>
        </div>
    </div>
</body>
</html>
